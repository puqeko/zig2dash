// Make a docset for the Zig Language Reference accroding to https://kapeli.com/docsets

const { JSDOM } = require("jsdom");
const fs = require("fs");
const { Sequelize } = require('sequelize');
const htmlMinify = require('html-minifier');

const BASE_URL = "https://ziglang.org/documentation/master";
const STD_PATH = "https://ziglang.org/documentation/master/std";
const GUIDE_PATH = "Zig\ Language\ Reference.html";
// TODO cross link to std lib
const DOCSET_NAME = "zigstd-guide.docset";
const DOCSET_PATH = DOCSET_NAME + "/Contents/Resources/Documents/";
const DRY_RUN = false;

const htmlMinOpts = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  // removeComments: true,  // don't remove Online Redirection comment tags
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true
};

function toc(doc, el, type, name) {
  const markEl = doc.createElement("a");
  markEl.name = `//apple_ref/cpp/${type}/${encodeURIComponent(name)}`;
  markEl.className = "dashAnchor";
  el.parentElement.insertBefore(markEl, el);
}

async function index(seq, name, type, filepath) {
  console.log(type, name, filepath);
  const CMD = "INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES ";
  await seq.query(CMD + `('${name}', '${type}', '${filepath}');`);  // add to table
}

async function main () {
  const seq = new Sequelize({
    dialect: 'sqlite',
    logging: false,
    storage: `${DOCSET_NAME}/Contents/Resources/docSet.dsidx`
  });

  if (!DRY_RUN) {
    fs.rmSync(DOCSET_NAME, {recursive: true, force: true});
    await seq.query(`CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);`);
    await seq.query(`CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);`);

    fs.copyFileSync("templates/icon.png", `${DOCSET_NAME}/icon.png`);
    fs.copyFileSync("templates/icon@2x.png", `${DOCSET_NAME}/icon@2x.png`);

    fs.mkdirSync(`${DOCSET_NAME}/Contents/`, {recursive: true});
    fs.copyFileSync("templates/info.plist", `${DOCSET_NAME}/Contents/info.plist`);
  }

  console.log(`Featching ${BASE_URL}`);
  const dom = await JSDOM.fromURL(BASE_URL, {
    runScripts: "dangerously",
    resources: "usable",
    pretendToBeVisual: true
  });
  console.log(`Waiting for page load...`);
  dom.window.addEventListener('load', async (event) => {
    const doc = dom.window.document;
    await index(seq, doc.querySelector("h1").textContent, "Guide", GUIDE_PATH);  // add to db

    // strip document: remove search bar and inputs
    doc.querySelector("#navigation").remove();
    // doc.querySelector("header").remove();
    doc.querySelector("link").remove();  // icon
    for (const a of doc.querySelectorAll("a.hdr")) a.remove();  // ยง links not needed in Dash

    // extract stylesheet to file to save space
    const styleEl = doc.querySelector("style");
    styleEl.textContent = styleEl.textContent +
    `#contents-wrapper, header {
      margin-left: 0;
    }
    header h1 {
      margin-top: 1em;
    }
    `;  // clean up the title a bit

    if (!DRY_RUN)
      fs.mkdirSync(DOCSET_PATH, {recursive: true});

    const titleEl = doc.querySelector("title");
    titleEl.innerHTML = "Zig Language Reference";
    const mainEl = doc.querySelector("#contents");

    // Add markers and index headers
    for (const h of mainEl.querySelectorAll("h1, h2, h3, h4, h5, h6")) {
      const headText = h.textContent.trim();
      h.textContent = headText;  // removes child link
      const filepath = GUIDE_PATH + "#" + h.id;
      if (headText.startsWith("@")) {  // builtin
        await index(seq, headText, "Builtin", filepath);
        toc(doc, h, "Builtin", headText);
      } else if (headText.toLowerCase() == headText) {  // probably language keyword eg for, while, return
        await index(seq, headText, "Keyword", filepath);
        toc(doc, h, "Keyword", headText);
      } else {  // guides
        await index(seq, headText, "Guide", filepath);
        toc(doc, h, "Guide", headText);
      }
    }

    // Specially add primitive types
    console.log("PIMITIVES");
    let primTblEl;
    for (const t of mainEl.querySelectorAll("table caption")) {
      if (t.textContent == "Primitive Types") primTblEl = t.parentElement;
    }
    if (!primTblEl) console.log("'Primitive Types' table not found.");
    else {
      const label = "#Primitive-Types";
      const filepath = GUIDE_PATH + label;  // Assuming this won't change
      const h = doc.querySelector(label);
      console.assert(h !== undefined);
      for (const th of primTblEl.querySelectorAll("tbody th")) {
        index(seq, th.textContent, "Type", filepath);
        toc(doc, h, "Type", th.textContent);
      }
    }

    // const filestr = dom.serialize();
    const filestr = htmlMinify.minify(temp.serialize(), htmlMinOpts);
    await fs.promises.writeFile(DOCSET_PATH + GUIDE_PATH, filestr);
  });
}

main();

// TODO: replace std lib references