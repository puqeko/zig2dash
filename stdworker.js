import process from 'process';
import { parentPort, workerData, isMainThread } from 'worker_threads';
import fs from 'fs-extra';
import { JSDOM, VirtualConsole, ResourceLoader } from 'jsdom';
import { Sequelize } from 'sequelize';
import htmlMinify from 'html-minifier';

const id = workerData?.id || '!';
const BASE_URL = workerData?.initData.baseUrl || "https://ziglang.org/documentation/0.9.1/std/";  // must end '/'
const DOC_NAME = workerData?.initData.DOC_NAME || "zig-wkr.docset"
const DOC_PATH = DOC_NAME + "/Contents/Resources/Documents/";

const log = console.log; //(...args) => console.log(`[${id}]`, ...args);
const htmlMinOpts = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  // removeComments: true,  // don't remove Online Redirection comment tags
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true
};
const baseUrl = new URL(BASE_URL);  // const since this is a single page webapp
const shouldFollow = (a) => {  // is hashlink to baseUrl page
  return a.hash != "" &&
    a.origin == baseUrl.origin &&
    a.pathname == baseUrl.pathname;
};

const toName = (key, rootPkgName) => {
  if (!rootPkgName) throw Error("please pass pkgRootName when using toName");
  if (!key) return rootPkgName;
  let s = key;
  if (s.startsWith("#")) s = s.slice(1);
  if (s.endsWith(";")) s = s.slice(0, -1);
  s = s.replace(";", ".");
  if (s.startsWith("root"))
    s = s.replace("root", rootPkgName);
  return s;
};
const toDir = (name) => {
  let d = name.split(".").slice(0, -1).join("/");
  return d ? (d + "/") : d;
}
const toPath = (name) => toDir(name) + name.split(".").at(-1) + ".html";
const tryMakeRelative = (sourceDir, path, dots) => {  // eg ("a/b/", "a/b/c/d.html") => "c/d.html"
  if (!path.startsWith(sourceDir)) return dots + path;
  return path.slice(sourceDir.length);
};

let dom = undefined;

const seen = new Set();
const libs = [];
let toFollow = [];
const startNextRender = async () => {
  let h = undefined, t = undefined, n = undefined;
  while (toFollow.length > 0) {
    const {type, hash, parentName} = toFollow.pop();
    if (seen.has(hash)) continue;
    seen.add(hash);
    h = hash; t = type; n = parentName;
    break;
  }
  while (!h && toFollow.length == 0 && libs.length > 0) {
    const {type, hash, name} = libs.pop();
    if (seen.has(hash)) continue;
    seen.add(hash);
    h = hash; t = type; n = name;
    break;
  }
  if (!isMainThread) {
    if (toFollow.length > 100) {
      // offload skippeed plus libs
      const toKeep = [];
      const toSend = [];
      for (let i = 0; i < toFollow.length; i++) {
        if (i%3 == 2) toKeep.push(toFollow[i]);
        else toSend.push(toFollow[i]);
      }
      toFollow = toKeep;
      parentPort.postMessage({tag: "data", data: toSend});
    }
  }
  if (!h) return Promise.resolve();
  dom.window.location.hash = h;  // render page at hash
  return new Promise((resolve) => dom.window.requestAnimationFrame(resolve)).then(() => {
    return {thisType: t, thisHash: h, parentName: n};
  });
};

async function index(db, name, type, filepath) {
  const CMD = "INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES ";
  // this description is displayed next to the result and distingushes similar results
  const pathStr = filepath + `<dash_entry_menuDescription=${encodeURIComponent(name)}>`;
  const nameStr = name.split(".").at(-1);
  await db.query(CMD + `('${nameStr}', '${type}', '${pathStr}');`);  // add to table
}

let nNoContent = 0;
// trigged by the parent, process the next hash link we are assigned and send back
// any hash links that we shouldFollow
const run = async (db, els, sects, next) => {
  const {thisType, thisHash, parentName} = next;
  const rootName = parentName.split('.').at(0);
  const {mainEl, titleEl, linkEl} = els;
  const name = toName(thisHash, rootName);
  titleEl.innerHTML = name.split(".").at(-1);
  const dirpath = toDir(name);
  const dotsToRoot = "../".repeat(dirpath.split("/").length - 1);
  linkEl.setAttribute("href", dotsToRoot + "style.css");
  
  // const filestr = dom.serialize();
  const allDocLinks = new Set(mainEl.querySelectorAll("a"));
  const excluded = new WeakSet();
  for (const a of dom.window.document.getElementById("listNav").querySelectorAll("a")) {
    excluded.add(a);  // would have already followed
    if (shouldFollow(a)) {
      a.href = tryMakeRelative(dirpath, toPath(toName(a.hash, rootName)), dotsToRoot);
    }
    else a.setAttribute("href", a.href);  // make sure no relative web urls
  }
  
  for (const type in sects) {
    const {el, anchorEl} = sects[type];
    const isHidden = el.className.split(/\s+/).includes("hidden");
    if (isHidden) anchorEl.className = "hidden";  // so dash doesn't register the anchor
    else anchorEl.className = "dashAnchor";
    for (const a of el.querySelectorAll("a")) {
      const pname = toName(a.hash, rootName);
      excluded.add(a);
      if (isHidden || a == anchorEl) continue;
      if (shouldFollow(a)) {
        if (pname.startsWith(parentName)) toFollow.unshift({type, hash: a.hash, parentName: pname});
        a.href = tryMakeRelative(dirpath, toPath(pname), dotsToRoot);
      } else a.setAttribute("href", a.href);  // make sure no relative web urls
    }
  }
  for (const a of allDocLinks) if (!excluded.has(a))
    a.setAttribute("href", a.href);  // no relative web urls
  const copy = new JSDOM(dom.serialize());
  const rendering = startNextRender();  // dom is hot until this is awaited, don't touch it

  // function anchors
  const listfnEl = copy.window.document.getElementById("listFns");
  if (!listfnEl) err("coud not find #listFns element");
  for (const lf of listfnEl.children) {
    const fnameEl = lf.querySelector(".tok-fn");
    if (!fnameEl) continue;  // TODO FIX
    const anchorEl = copy.window.document.createElement("a");
    anchorEl.setAttribute("name", `//apple_ref/cpp/Function/${encodeURIComponent(fnameEl.textContent)}`);
    anchorEl.className = "dashAnchor";
    lf.insertBefore(anchorEl, lf.firstElementChild);
  }

  // online redirect marker
  const orEl = copy.window.document.createComment(` Online page at ${baseUrl.href + thisHash} `);
  const htmlEl = copy.window.document.querySelector("html");
  htmlEl.insertBefore(orEl, htmlEl.children[0]);

  for (const el of copy.window.document.querySelectorAll(".hidden")) el.remove();
  for (const s of copy.window.document.querySelectorAll("script")) s.remove();

  const docsEl = copy.window.document.querySelector(".docs");
  if (docsEl.children.length == 0) {
    nNoContent += 1;
    docsEl.innerHTML = `Nothing documented yet. <a href='${baseUrl.href + thisHash}'>Try the website</a>.`;
  }

  const filestr = htmlMinify.minify(copy.serialize(), htmlMinOpts);
  const filepath = toPath(name);
  const writing = fs.outputFile(DOC_PATH + filepath, filestr);
  const indexing = index(db, name, thisType, filepath);
  await Promise.all([writing, indexing]);
  return rendering;
};

let isLoadingResourcesDisabled = false;  // set to stop script and link tags loading
class DisablableResourceLoader extends ResourceLoader {
  fetch (url, options) {
    if (isLoadingResourcesDisabled) return null;
    return super.fetch(url, options);
  }
}

// get and emulate webapp at workerData.initData.basUrl address then do some prepocessing before
// setting up the process handler and sending back the root packages discovered
const initWorker = async () => {
  log(baseUrl.href);
  dom = await JSDOM.fromURL(baseUrl, {
    runScripts: "dangerously",
    resources: "usable",
    pretendToBeVisual: true,
    virtualConsole: new VirtualConsole(),  // todo output to file
    resources: new DisablableResourceLoader()
  });
  log("Waiting for page load...");
  const doc = dom.window.document;
  for (const a of doc.querySelectorAll("a")) a.setAttribute("href", a.href);  // no relative urls
  await new Promise((resolve) => dom.window.addEventListener('load', resolve));
  let version = dom.window.zigAnalysis.params.zigVersion;
  if (!/^\d+\.\d+\.\d+$/.test(version)) version += " (master)";
  log(`Loaded version: ${version}`);

  let pkgsUl = doc.querySelector(".packages");
  const toFollowLibs = [];
  if (!pkgsUl) throw Error("could not find package list");
  for (const pkgLi of pkgsUl.children) {
    const a = pkgLi.querySelector('a');
    toFollowLibs.push({type: "Library", hash: a.hash, name: a.textContent});
  }

  // strip document to save space
  // doc.querySelector(".banner").remove();  // might be good to show 'beta' banner
  for (const a of doc.querySelectorAll(".banner a")) a.remove();  // without links
  const banEl = doc.querySelector(".banner");
  banEl.textContent = banEl.textContent.split('.').at(0) + ".";
  doc.getElementById("searchPlaceholder")?.remove();
  doc.getElementById("sectSearchResults")?.remove();
  doc.getElementById("sectSearchNoResults")?.remove();
  doc.getElementById("helpModal")?.remove();
  doc.getElementById("status").remove();
  doc.querySelector(".sidebar")?.remove();
  doc.querySelector(".flex-filler")?.remove();
  doc.querySelector("link").remove();  // icon
  for (const inp of doc.querySelectorAll("input")) inp.remove();
  const linkEl = doc.createElement("link");
  linkEl.setAttribute("href", "style.css");  // update for each page later
  linkEl.setAttribute("rel", "stylesheet");
  isLoadingResourcesDisabled = true;  // don't load newly inserted link tag
  doc.querySelector("head").appendChild(linkEl);
  
  const sects = {
    "Type": "sectTypes",  // these are id values for getElementById labeled with dash types
    "Namespace": "sectNamespaces",  // to be replaced by {element, anchor, anchorElements}
    "Global": "sectGlobalVars",
    "Function": "sectFns",
    "Value": "sectValues",
    "Error": "sectErrSets",
  };
  for (const type in sects) {
    const el = doc.getElementById(sects[type]);
    const h2 = el.querySelector('h2');
    const anchorEl = doc.createElement("a");
    anchorEl.setAttribute("name", `//apple_ref/cpp/Section/${encodeURIComponent(h2.textContent)}`);
    anchorEl.className = "dashAnchor";
    el.insertBefore(anchorEl, h2);
    sects[type] = {el, anchorEl, elNL: el.getElementsByTagName("a")};
  }
  const mainEl = doc.querySelector(".docs");
  const titleEl = doc.querySelector("title");
  const els = {mainEl, titleEl, linkEl};

  let shouldInit = true;
  if (!isMainThread) shouldInit = !fs.pathExistsSync(DOC_PATH);

  const db = new Sequelize({
    dialect: 'sqlite',
    logging: false,
    storage: `${DOC_NAME}/Contents/Resources/docSet.dsidx`
  });

  if (shouldInit) {
    await fs.rm(DOC_NAME, {recursive: true, force: true});
    await db.query(`CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);`);
    await db.query(`CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);`);
    await fs.copy("template", DOC_NAME);
  }

  const styleEl = doc.querySelector("style");
  const spath = `${DOC_PATH}style.css`;
  if (!fs.pathExistsSync(spath)) {  // means won't be updated with "Merge" option
    fs.outputFileSync(spath, styleEl.innerHTML + "\n.flex-main{overflow-y: auto;}");
    log(`Extracted style tag`);
  }
  styleEl.remove();

  const runFn = run.bind(run, db, els, sects);

  if (isMainThread) {
    libs.push(...toFollowLibs);
    runner(runFn);
  } else {
    parentPort.postMessage({tag: "finished", data: toFollowLibs});
    parentPort.on("message", (o) => {
      const {tag, data} = o;
      if (tag == "job") {
        if (data.lib) libs.push(data.lib);
        if (data.pack) for (const it of data.pack) toFollow.push(it);
        runner(runFn);
      } else throw Error(`unexpected tag '${tag}'`);
    });
  }
};

let nProcessed = 0;
const runner = async (runFn) => {
  log("[Processed, No Content] Name");
  let next = await startNextRender();
  while (next) {
    const pnext = await runFn(next);
    nProcessed += 1;
    if (isMainThread) {
      process.stdout.clearLine();
      process.stdout.cursorTo(0);
      process.stdout.write(`[${nProcessed}, ${nNoContent}] ` + toName(next.thisHash, next.parentName.split('.').at(0)));
    }
    next = pnext;
  }

  if (isMainThread) log("\nDone");
  else parentPort.postMessage({tag: "finished", data: nProcessed});
}

initWorker();