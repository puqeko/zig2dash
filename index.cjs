const jsdom = require("jsdom");
const { JSDOM } = jsdom;
const fs = require("fs");
const { Sequelize } = require('sequelize');

const htmlMinify = require('html-minifier');

const htmlMinOpts = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  removeComments: true,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true
};

function toName(key) {
  if (!key) return "std";
  let s = key;
  if (s.startsWith("#")) s = s.slice(1);
  if (s.endsWith(";")) s = s.slice(0, -1);

  // s = s.replace(";", ".");
  s = s.split(";").at(-1);
  if (s.startsWith("root")) s = s.replace("root", "std");  // assuming here
  return s;
}

function toPath(name) {
  return name.replaceAll(".", "/") + ".html";
}

async function finishedLoad(dom, url, seq, event) {
  let version = dom.window.zigAnalysis.params.zigVersion;
  if (!/^\d+\.\d+\.\d+$/.test(version)) {
    version += " (master)";
  }
  console.log(dom.window.location.toString());
  console.log(version);

  const doc = dom.window.document;

  const secs = [
    ["#sectTypes", "Type"],
    ["#sectNamespaces", "Namespace"],
    ["#sectGlobalVars", "Global"],
    ["#sectFns", "Function"],
    // ["#sectValues", "Value"],
    ["#sectErrSets", "Error"],
  ];

  // cleanup: remove search bar and inputs
  doc.querySelector("#searchPlaceholder").remove();
  doc.querySelector("label").remove();
  doc.querySelector(".sidebar").remove();
  doc.querySelector(".banner").remove();
  doc.querySelector("#status").remove();
  doc.querySelector("link").remove();  // icon
  for (const inp of doc.querySelectorAll("input")) {
    inp.remove();
  }

  // remove stylesheet to file
  const styleEl = doc.querySelector("style");
  fs.mkdirSync("zigstd.docset/Contents/Resources/Documents/", {recursive: true});
  fs.writeFileSync("zigstd.docset/Contents/Resources/Documents/style.css", styleEl.innerHTML);
  styleEl.remove();

  let entries = new Map();
  let todo = [];
  const root = dom.window.zigAnalysis.packages[dom.window.zigAnalysis.rootPkg].name;
  let cur = "";
  entries.set("", "Library");

  async function parse(_) {

    const name = toName(cur);
    const filepath = toPath(name);
    console.log(name);

    for (const tup of secs) {
      const query = tup[0];
      const type_entry = tup[1];
      const links = doc.querySelector(query).querySelectorAll("a");
      for (const l of links) {
        if (l.hash.length > 0 && l.origin + l.pathname == url) {
          const key = l.hash;
          if (!entries.has(key)) {
            todo.push(key);
            entries.set(key, type_entry);
          } else if (entries.get(key) != type_entry) {
            console.log(`Key: ${key} has multiple entry types ${entries.get(key)}, ${type_entry}`);
          }
          l.href = toPath(toName(key));
        } else if (!l.origin) {
          l.href = url + l.href;
        }
      }
    }

    if (filepath.indexOf("/") >= 0) {
      const dirpath = filepath.slice(0, filepath.lastIndexOf("/"));
      fs.mkdirSync("zigstd.docset/Contents/Resources/Documents/" + dirpath, {recursive: true});
    }
    const temp = new JSDOM(dom.window.document.documentElement.outerHTML, {});
    const linkEl = temp.window.document.createElement("link");
    linkEl.href = "../".repeat(filepath.split("/").length - 1) + "style.css";
    linkEl.rel = "stylesheet";
    temp.window.document.querySelector("head").appendChild(linkEl);
    for (const hid of temp.window.document.querySelectorAll(".hidden")) hid.remove();
    let n = name.split(".").at(-1);
    await seq.query(`INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES ('${n}', '${entries.get(cur)}', '${filepath}');`);
    fs.writeFileSync("zigstd.docset/Contents/Resources/Documents/" + filepath, htmlMinify.minify(temp.serialize(), htmlMinOpts));

    // next page if still more todo
    if (todo.length > 0) {
      cur = todo.pop();
      dom.window.location.hash = cur;
      dom.window.requestAnimationFrame(parse);
    }
  }

  parse();
  // add to db
}

async function main () {

  const seq = new Sequelize({
    dialect: 'sqlite',
    storage: 'zigstd.docset/Contents/Resources/docSet.dsidx'
  });

  try {
    await seq.query(`DROP TABLE searchIndex;`);
  } catch {};
  await seq.query(`CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);`);
  await seq.query(`CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);`);

  const options = {
    runScripts: "dangerously",
    resources: "usable",
    pretendToBeVisual: true
  };
  const url = "https://ziglang.org/documentation/master/std/";
  const dom = await JSDOM.fromURL(url, options);
  dom.window.addEventListener('load', (event) => {
    finishedLoad(dom, url, seq, event);
  });
}

main();