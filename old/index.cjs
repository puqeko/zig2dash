// Make a docset for the Zig Standard Lib accroding to https://kapeli.com/docsets
const jsdom = require("jsdom");
const { JSDOM, VirtualConsole } = jsdom;
const fs = require("fs");
const { Sequelize } = require('sequelize');
const htmlMinify = require('html-minifier');

const BASE_URL = "https://ziglang.org/documentation/master/std";
const DOCSET_NAME = "zig-std-old.docset"
const DOCSET_PATH = DOCSET_NAME + "/Contents/Resources/Documents/";
const DRY_RUN = false;

const htmlMinOpts = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  // removeComments: true,  // don't remove Online Redirection comment tags
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true
};

function clearLog() {
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
}

function logUpdate(...args) {
  clearLog();
  const [cols, rows] = process.stdout.getWindowSize()
  process.stdout.write(args.join(" ").slice(0, cols));
}

// take a hash and convert to name
// eg #root;Array.thing  =>  std.Array.thing
function toName(key, pkgRootName) {
  if (!pkgRootName) throw Error("please pass pkgRootName when using toName");
  if (!key) return pkgRootName;
  let s = key;
  if (s.startsWith("#")) s = s.slice(1);
  if (s.endsWith(";")) s = s.slice(0, -1);
  s = s.replace(";", ".");
  if (s.startsWith("root")) {
    s = s.replace("root", pkgRootName);
  }
  return s;
}

function toPath(name) {
  return name.replaceAll(".", "/") + ".html";
}

function getFullUrl(a) {
  let href = a.href;
  if (!a.origin || a.origin == "null") {
    href = BASE_URL;
    // TODO find out what this weird behaviour with a.pathname and a.hash is about
    // They are giving empty string when they should not?
    if (!(a.pathname + a.search + a.hash).trim())
      href = [href, a.href].join("/");
    else {
      if (a.pathname != "blank") href += a.pathname;
      href += a.search + a.hash;
    }
  }
  return (new URL(href, BASE_URL)).href;
}

async function index(seq, name, type, filepath) {
  const CMD = "INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES ";
  // this description is displayed next to the result and distingushes similar results
  const pathStr = filepath + `<dash_entry_menuDescription=${encodeURIComponent(name)}>`;
  const nameStr = name.split(".").at(-1);
  await seq.query(CMD + `('${nameStr}', '${type}', '${pathStr}');`);  // add to table
}

async function onFinishedFirstLoad(dom, seq, _) {
  // sections to process
  const secids = {
    "Type": "#sectTypes",
    "Namespace": "#sectNamespaces",
    "Global": "#sectGlobalVars",
    "Function": "#sectFns",
    "Value": "#sectValues",
    "Error": "#sectErrSets",
  };

  let seen = new Map();  // keep track of hashes for which we know the type

  // find packages
  const doc = dom.window.document;
  let pkgsUl = doc.querySelector(".packages");
  
  let libs = [];
  if (!pkgsUl) throw Error("could not find package list");
  for (const pkgLi of pkgsUl.children) {
    const a = pkgLi.querySelector('a');
    const name = a.textContent;
    const hash = a.hash;
    libs.push({hash, name});
    seen.set(hash, "Library");
  }
  console.log(`Discovered ${libs.length} packages: ${libs.map((a) => a.name).join(", ")}`);
  if (DRY_RUN) console.log("WARNING: is dry run");

  // strip document: remove search bar and inputs
  // doc.querySelector("#searchPlaceholder").remove();
  // doc.querySelector("label").remove();
  doc.querySelector(".sidebar").remove();
  doc.querySelector(".flex-filler").remove();
  // doc.querySelector(".banner").remove();  // might be good to show 'beta' banner
  doc.querySelector("#status").remove();
  doc.querySelector("link").remove();  // icon
  for (const inp of doc.querySelectorAll("input")) {
    inp.remove();
  }

  // extract stylesheet to file to save space
  const styleEl = doc.querySelector("style");
  if (!DRY_RUN) {
    fs.mkdirSync(DOCSET_PATH, {recursive: true});
    fs.writeFileSync(`${DOCSET_PATH}/style.css`, styleEl.innerHTML);
  }
  styleEl.remove();

  let nProcessing = 0;
  let next = [];  // hashes to be processed
  let pkgRootName;
  let cur;
  {
    const {hash, name} = libs.pop();
    pkgRootName = name;
    cur = hash;
  }

  // create copy of dom, parse results, output to file, populate db
  // follow links, add to stack, process next on stack until empty
  async function onRender(_) {
    const name = toName(cur, pkgRootName);
    const filepath = toPath(name);
    const thisType = seen.get(cur);
    if (thisType == "Library") {
      clearLog();
      console.log(`Traversing '${pkgRootName}'...`);
    }

    nProcessing += 1;
    logUpdate(`[${nProcessing}]`, thisType, name, filepath);

    let ip = undefined;
    if (!DRY_RUN)
      ip = index(seq, name, thisType, filepath);  // insert into db
    let mp = undefined;
    if (!DRY_RUN && filepath.includes("/"))  // create empty dir if it doesn't exist
       mp = fs.promises.mkdir(DOCSET_PATH + filepath.slice(0, filepath.lastIndexOf("/")), {recursive: true});

    const temp = new JSDOM(dom.window.document.documentElement.outerHTML);  // copy dom context as non runable
    const tdoc = temp.window.document;

    // remove hidden sections
    for (const hid of tdoc.querySelectorAll(".hidden")) hid.remove();

    const allLinks = new Set(tdoc.querySelectorAll("a"));
    const linkSets = {};
    for (const type in secids)
      linkSets[type] = new Set(tdoc.querySelectorAll(`${secids[type]} a`));

    const dotsToRoot = "../".repeat(filepath.split("/").length - 1);
    for (const a of allLinks) {
      // webapp uses #root;Type.func format to navigate
      // only index links to this page
      // if (a.origin == '' || a.origin == "null") console.log(a.hash, `'${a.origin}'`);
      let is_suitable = a.href.trim() != "" && a.hash.length > 0 && (
        (a.origin == '' && a.pathname == '') ||
        (a.origin == "null" && a.pathname == "blank")
        // TODO make compare that ignores trailing '/' and check out with other werid url behaviour
        || a.origin + a.pathname == BASE_URL + "/"
      );
      let is_indexed = is_suitable && seen.has(a.hash);
      if (is_suitable && !is_indexed) {
        for (const type in linkSets) {
          if (linkSets[type].has(a)) {
            next.push(a.hash);  // to be indexed
            seen.set(a.hash, type);
            is_indexed = true;
            break;
          }
        }
      }
      if (is_indexed) a.href = dotsToRoot + toPath(toName(a.hash, pkgRootName));  // convert to relative docset path
      else a.href = getFullUrl(a);  // ensure full web address linked since local file will not exist
    }

    // start rendering next page, okay since we made copy of this dom context
    let thisCur = cur;
    let shouldRedraw = false;
    if (next.length > 0) {
      cur = next.pop();
      shouldRedraw = true;
    }
    // check for more libraries
    else if (next.length == 0 && libs.length > 0) {
      const {hash, name} = libs.pop();
      pkgRootName = name;
      cur = hash;
      shouldRedraw = true;
    } else {
      console.log("Done");
    }
    if (shouldRedraw) {
      dom.window.location.hash = cur;
      dom.window.requestAnimationFrame(onRender);  // wait for redraw
    }
    
    // link stylesheet at root
    const linkEl = tdoc.createElement("link");
    linkEl.href = dotsToRoot + "style.css";
    linkEl.rel = "stylesheet";
    tdoc.querySelector("head").appendChild(linkEl);

    // online redirect marker
    const orEl = tdoc.createComment(` Online page at ${BASE_URL + thisCur} `);
    const htmlEl = tdoc.querySelector("html");
    htmlEl.insertBefore(orEl, htmlEl.children[0]);

    // mark sections
    for (const h2 of tdoc.querySelectorAll("section.docs h2")) {
      const markEl = tdoc.createElement("a");
      markEl.setAttribute("name", `//apple_ref/cpp/Section/${encodeURIComponent(h2.textContent)}`);
      markEl.className = "dashAnchor";
      h2.parentElement.insertBefore(markEl, h2);
    }

    // mark function signatures
    const lfn = tdoc.querySelector("#listFns");
    if (lfn) for (const lf of lfn.children) {
      const fnameEl = lf.querySelector("#listFns .tok-fn");
      const markEl = tdoc.createElement("a");
      markEl.setAttribute("name", `//apple_ref/cpp/Function/${encodeURIComponent(fnameEl.textContent)}`);
      markEl.className = "dashAnchor";
      lf.insertBefore(markEl, lf.firstElementChild);
    }

    const titleEL = tdoc.querySelector("title");  // shows in full text search
    titleEL.innerHTML = name.split(".").at(-1);

    if (!DRY_RUN) {
      // const filestr = temp.serialize();
      const filestr = htmlMinify.minify(temp.serialize(), htmlMinOpts);
      if (mp !== undefined) await mp;  // mkdir
      await fs.promises.writeFile(DOCSET_PATH + filepath, filestr);
      if (ip !== undefined) await ip;  // db entry
    }
  }

  await onRender();
}

async function main () {
  const seq = new Sequelize({
    dialect: 'sqlite',
    logging: false,
    storage: `${DOCSET_NAME}/Contents/Resources/docSet.dsidx`
  });

  if (!DRY_RUN) {
    fs.rmSync(DOCSET_NAME, {recursive: true, force: true});
    await seq.query(`CREATE TABLE searchIndex(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, type TEXT, path TEXT, parent INTEGER);`);
    await seq.query(`CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path, parent);`);
    
    fs.mkdirSync(`${DOCSET_NAME}/Contents/`, {recursive: true});
    fs.copyFileSync("template/icon.png", `${DOCSET_NAME}/icon.png`);
    fs.copyFileSync("template/icon@2x.png", `${DOCSET_NAME}/icon@2x.png`);
    fs.copyFileSync("template/Contents/info.plist", `${DOCSET_NAME}/Contents/info.plist`);
  }

  const virtualConsole = new VirtualConsole();  // todo output to file

  console.log(`Featching ${BASE_URL}`);
  const dom = await JSDOM.fromURL(BASE_URL, {
    runScripts: "dangerously",
    resources: "usable",
    pretendToBeVisual: true,
    virtualConsole: virtualConsole
  });
  console.log(`Waiting for page load...`);
  dom.window.addEventListener('load', async (event) => {
    let version = dom.window.zigAnalysis.params.zigVersion;
    if (!/^\d+\.\d+\.\d+$/.test(version)) {
      version += " (master)";
    }
    console.log(`Loaded version: ${version}`);
    onFinishedFirstLoad(dom, seq, event);
  });
}

// process.on('error', () => {});
main();

// select version
// select overwrite