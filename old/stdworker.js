import { parentPort, workerData, isMainThread } from 'worker_threads';
import fs from 'fs-extra';
import { JSDOM, VirtualConsole, ResourceLoader } from 'jsdom';
import htmlMinify from 'html-minifier';

const DOC_PATH = workerData.initData.DOC_PATH;
const id = workerData.id;
const log = (...args) => console.log(`[${id}]`, ...args);
const htmlMinOpts = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  // removeComments: true,  // don't remove Online Redirection comment tags
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true
};
const baseUrl = new URL(workerData.initData.baseUrl);  // const since this is a single page webapp
const shouldFollow = (a) => {  // is hashlink to baseUrl page
  return a.hash != "" &&
    a.origin == baseUrl.origin &&
    a.pathname == baseUrl.pathname;
};

const toName = (key, rootPkgName) => {
  if (!rootPkgName) throw Error("please pass pkgRootName when using toName");
  if (!key) return rootPkgName;
  let s = key;
  if (s.startsWith("#")) s = s.slice(1);
  if (s.endsWith(";")) s = s.slice(0, -1);
  s = s.replace(";", ".");
  if (s.startsWith("root"))
    s = s.replace("root", rootPkgName);
  return s;
};
const toDir = (name) => {
  let d = name.split(".").slice(0, -1).join("/");
  return d ? (d + "/") : d;
}
const toPath = (name) => toDir(name) + name.split(".").at(-1) + ".html";
const tryMakeRelative = (sourceDir, path) => {  // eg ("a/b/", "a/b/c/d.html") => "c/d.html"
  if (!path.startsWith(sourceDir)) return path;
  return path.slice(sourceDir.length);
};

// trigged by the parent, process the next hash link we are assigned and send back
// any hash links that we shouldFollow
const process = async (dom, els, sects, msgData) => {
  const {mainEl, titleEl, linkEl} = els;
  const {thisHash, rootName} = msgData;
  dom.window.location.hash = thisHash;  // re-render page at thisHash
  await new Promise((resolve) => dom.window.requestAnimationFrame(resolve));
  const name = toName(thisHash, rootName);
  titleEl.innerHTML = name.split(".").at(-1);
  const dirpath = toDir(name);
  const dotsToRoot = "../".repeat(dirpath.split("/").length);
  linkEl.setAttribute("href", dotsToRoot + "style.css");

  const allDocLinks = new Set(mainEl.querySelectorAll("a"));
  const excluded = new WeakSet();
  for (const a of dom.window.document.getElementById("listNav").querySelectorAll("a")) {
    excluded.add(a);  // would have already followed
    if (shouldFollow(a)) a.href = tryMakeRelative(dirpath, toPath(toName(a.hash, rootName)));
    else a.setAttribute("href", a.href);  // make sure no relative web urls
  }
  
  const toFollow = [];
  for (const type in sects) {
    const {el, anchorEl} = sects[type];
    const isHidden = el.className.split(/\s+/).includes("hidden");
    if (isHidden) anchorEl.className = "hidden";  // so dash doesn't register the anchor
    else anchorEl.className = "dashAnchor";
    for (const a of el.querySelectorAll("a")) {
      excluded.add(a);
      if (isHidden || a == anchorEl) continue;
      if (shouldFollow(a)) {
        toFollow.push({type, hash: a.hash, rootName});
        a.href = tryMakeRelative(dirpath, toPath(toName(a.hash, rootName)));
      } else a.setAttribute("href", a.href);  // make sure no relative web urls
    }
  }
  if (toFollow.length) parentPort.postMessage({tag: "data", data: toFollow});
  for (const a of allDocLinks) if (!excluded.has(a))
    a.setAttribute("href", a.href);  // no relative web urls

  const copy = new JSDOM(dom.serialize());

  // function anchors
  const listfnEl = copy.window.document.getElementById("listFns");
  if (!listfnEl) err("coud not find #listFns element");
  for (const lf of listfnEl.children) {
    const fnameEl = lf.querySelector(".tok-fn");
    if (!fnameEl) continue;  // TODO FIX
    const anchorEl = copy.window.document.createElement("a");
    anchorEl.setAttribute("name", `//apple_ref/cpp/Function/${encodeURIComponent(fnameEl.textContent)}`);
    anchorEl.className = "dashAnchor";
    lf.insertBefore(anchorEl, lf.firstElementChild);
  }

  // online redirect marker
  const orEl = copy.window.document.createComment(` Online page at ${baseUrl.href + thisHash} `);
  const htmlEl = copy.window.document.querySelector("html");
  htmlEl.insertBefore(orEl, htmlEl.children[0]);

  for (const el of copy.window.document.querySelectorAll(".hidden")) el.remove();

  const filestr = htmlMinify.minify(copy.serialize(), htmlMinOpts);
  // const filestr = dom.serialize();
  fs.outputFileSync(DOC_PATH + toPath(name), filestr);
  parentPort.postMessage({tag: "finished", data: name});
};

let isLoadingResourcesDisabled = false;  // set to stop script and link tags loading
class DisablableResourceLoader extends ResourceLoader {
  fetch (url, options) {
    if (isLoadingResourcesDisabled) return null;
    return super.fetch(url, options);
  }
}

// get and emulate webapp at workerData.initData.basUrl address then do some prepocessing before
// setting up the process handler and sending back the root packages discovered
const initWorker = async () => {
  log(baseUrl.href);
  const dom = await JSDOM.fromURL(baseUrl, {
    runScripts: "dangerously",
    resources: "usable",
    pretendToBeVisual: true,
    virtualConsole: new VirtualConsole(),  // todo output to file
    resources: new DisablableResourceLoader()
  });
  log("Waiting for page load...");
  const doc = dom.window.document;
  for (const a of doc.querySelectorAll("a")) a.setAttribute("href", a.href);  // no relative urls
  await new Promise((resolve) => dom.window.addEventListener('load', resolve));
  let version = dom.window.zigAnalysis.params.zigVersion;
  if (!/^\d+\.\d+\.\d+$/.test(version)) version += " (master)";
  log(`Loaded version: ${version}`);

  let libs = [];
  let pkgsUl = doc.querySelector(".packages");
  if (!pkgsUl) throw Error("could not find package list");
  for (const pkgLi of pkgsUl.children) {
    const a = pkgLi.querySelector('a');
    libs.push({type: "Library", hash: a.hash, name: a.textContent});
  }

  // strip document to save space
  // doc.querySelector(".banner").remove();  // might be good to show 'beta' banner
  for (const a of doc.querySelectorAll(".banner a")) a.remove();  // without links
  doc.getElementById("searchPlaceholder")?.remove();
  doc.getElementById("sectSearchResults")?.remove();
  doc.getElementById("sectSearchNoResults")?.remove();
  doc.getElementById("helpModal")?.remove();
  doc.getElementById("status").remove();
  doc.querySelector(".sidebar")?.remove();
  doc.querySelector(".flex-filler")?.remove();
  doc.querySelector("link").remove();  // icon
  for (const inp of doc.querySelectorAll("input")) inp.remove();
  const styleEl = doc.querySelector("style");
  const spath = `${DOC_PATH}/style.css`;
  if (!fs.pathExistsSync(spath))  // means won't be updated with "Merge" option
    fs.outputFileSync(spath, styleEl.innerHTML);
  styleEl.remove();
  const linkEl = doc.createElement("link");
  linkEl.setAttribute("href", "style.css");  // update for each page later
  linkEl.setAttribute("rel", "stylesheet");
  isLoadingResourcesDisabled = true;  // don't load newly inserted link tag
  doc.querySelector("head").appendChild(linkEl);
  
  const sects = {
    "Type": "sectTypes",  // these are id values for getElementById labeled with dash types
    "Namespace": "sectNamespaces",  // to be replaced by {element, anchor, anchorElements}
    "Global": "sectGlobalVars",
    "Function": "sectFns",
    "Value": "sectValues",
    "Error": "sectErrSets",
  };
  for (const type in sects) {
    const el = doc.getElementById(sects[type]);
    const h2 = el.querySelector('h2');
    const anchorEl = doc.createElement("a");
    anchorEl.setAttribute("name", `//apple_ref/cpp/Section/${encodeURIComponent(h2.textContent)}`);
    anchorEl.className = "dashAnchor";
    el.insertBefore(anchorEl, h2);
    sects[type] = {el, anchorEl, elNL: el.getElementsByTagName("a")};
  }
  const mainEl = doc.querySelector(".docs");
  const titleEl = doc.querySelector("title");
  const els = {mainEl, titleEl, linkEl};
  const boundProcess = process.bind(process, dom, els, sects);
  parentPort.on("message", (msg) => {
    if (msg.tag == 'job') boundProcess(msg.data);
    else throw Error(`unexpected tag '${msg.tag}'`);
  });
  parentPort.postMessage({tag: "finished", data: libs})
};

initWorker();